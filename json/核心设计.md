C++ json库在设计上所要解决的核心问题就在于：如何提供优雅直观的接口去像JS,Python那样操作json对象。在此基础上，再将性能发挥到极致。

Json本身是一个字符串，它有着特定的fmt，为了能够灵活操作，库设计者需要去把它parse成一个对象，使用设计好的接口去便捷高效操作它。

C++发展了这么多年，诞生了许多知名的json库，这其中，热度最高的便是：[nlohmann/json](https://github.com/sponsors/nlohmann)

本文旨在对该开源仓库进行深度剖析，源码之前，了无秘密。

## Json类设计
用于表达json对象的`class`是`basic_json`类模板，它的定义有5k行代码，看着相当唬人。但实际上，只要我们掌握阅读一个类的方法，了解它的能力，就会发现拆解源代码的实现工作量并不大。

### Json的类型表达
拆解类模板设计的第一步就是看它的模板头声明与类继承关系。

Json的解析无非就是对几种可枚举的类型进行Key/Value的处理：
- 对象
- 数组
- 字符串
- 布尔
- 有符号整型数
- 无符号整型数
- 浮点数
- 二进制bytes

在C++中，每种类型都很容易联想到对应的基础类型或是标准容器。比如对象适合用`std::map`，数组适合用`std::vector`，字符串适合用`std::string`。其他几个也各有合适的基础类型。但直接就绑定使用这些类型未免过于僵硬，库的设计往往都要考虑灵活的延展性，因此，`basic_json`在设计上，允许通过模板参数来指定每一种类型，这在模板元编程中，术语叫做strategy。

```cpp
template<template<typename U, typename V, typename... Args> class ObjectType =  
         std::map,  
         template<typename U, typename... Args> class ArrayType = std::vector,  
         class StringType = std::string, class BooleanType = bool,  
         class NumberIntegerType = std::int64_t,  
         class NumberUnsignedType = std::uint64_t,  
         class NumberFloatType = double,  
         template<typename U> class AllocatorType = std::allocator,  
         template<typename T, typename SFINAE = void> class JSONSerializer =  
         adl_serializer,  
         class BinaryType = std::vector<std::uint8_t>, 
         class CustomBaseClass = void>  
class basic_json 
	: public ::nlohmann::detail::json_base_class<CustomBaseClass> {
	......
};
```

基础类型的指派是一目了然的，这里重点说下`ObjectType`和`ArrayType`，这两个都是模板模板参数，对于前者来说，由于我们只关心对象的KV类型，所以模板参数的前两个`U`和`V`要固定下来，为了能够支持更灵活的类型，额外再提供一个可变模板参数`Args`，后者亦然。`std::map`和`std::vector`满足二者的模板参数列表，它们分别被指定为默认值。

除了类型相关的模板参数以外，这里还指定了默认的内存分配器类型为`std::allocator`，默认的序列化类型为库实现的`adl_serializer`，默认的二进制类型`BinaryType`为`std::vector<std::uint8_t>`，默认的`CustomBaseClass`为`void`。`CustomBaseClass`见名知意，设计的本意是让`basic_json`可以继承用户自定义的某个基类，可能是想继承到某些能力，或是和其他库设计的某些类混用，适用多态的能力。由于默认情况下模板参数指定的是`void`，而在C++语法规则里是不能去继承`void`类型的，因此这里使用type trait技巧包装了一下：

```cpp
struct json_default_base {};  
  
template<class T>  
using json_base_class = typename std::conditional <  
                        std::is_same<T, void>::value,  
                        json_default_base,  
                        T  
                        >::type;
```

实际上直接写作`class CustomBaseClass = detail::json_default_base`达成的效果完全一样，只是`void`更能表达设计的意图。

### 核心类型定义
类模板在设计时，不论是strategy/policy型模板参数，还是直接引用的外部类型，直接使用都较为臃肿。惯例上，会直接（别名）或间接（Type Trait）定义出核心类内类型，一方面可以简化模板实现代码的编写，另一方面也可以屏蔽外部的变化并约束引用的类型。

而想要了解哪些类内定义最为核心，可以从先寻找`basic_json`内部的成员变量出发。`basic_json`类内实际上只有一个成员变量：

```cpp
class basic_json{
	struct data  
	{  
	    /// the type of the current element  
	    value_t m_type = value_t::null;  
	  
	    /// the value of the current element  
	    json_value m_value = {};  
	  
	    data(const value_t v)  
	        : m_type(v), m_value(v)  
	    {  
	    }  
	  
	    data(size_type cnt, const basic_json& val)  
	        : m_type(value_t::array)  
	    {  
	        m_value.array = create<array_t>(cnt, val);  
	    }  
		// 允许默认构造和移动构造，但禁止拷贝
	    data() noexcept = default;  
	    data(data&&) noexcept = default;  
	    data(const data&) noexcept = delete;  
	    data& operator=(data&&) noexcept = delete;  
	    data& operator=(const data&) noexcept = delete;  
	  
	    ~data() noexcept  
	    {  
	        m_value.destroy(m_type);  
	    }  
	};  

	data m_data = {};
};
```
内部类型`data`包裹了整个`basic_json`最为核心的两个类型设计：`value_t`和`json_value`，前者用于表示该`basic_json`对象具体是哪种类型，后者则存储对应的值。

#### `m_type`
显然，对于`value_t`来说，在设计上应该是枚举，我们来看看`value_t`的定义：

```cpp
class basic_json {
public:  
  using value_t = detail::value_t;
};

enum class value_t : std::uint8_t  
{  
    null,             ///< null value  
    object,           ///< object (unordered set of name/value pairs)  
    array,            ///< array (ordered collection of values)  
    string,           ///< string value  
    boolean,          ///< boolean value  
    number_integer,   ///< number value (signed integer)  
    number_unsigned,  ///< number value (unsigned integer)  
    number_float,     ///< number value (floating-point)  
    binary,           ///< binary array (ordered collection of bytes)  
    discarded         ///< discarded by the parser callback function  
};
```
果然与我们的猜想如出一辙。

#### `m_value`
再来看看`json_value`:

```cpp
class basic_json {
  private:
	union json_value  
	{  
	    /// object (stored with pointer to save storage)  
	    object_t* object;  
	    /// array (stored with pointer to save storage)  
	    array_t* array;  
	    /// string (stored with pointer to save storage)  
	    string_t* string;  
	    /// binary (stored with pointer to save storage)  
	    binary_t* binary;  
	    /// boolean  
	    boolean_t boolean;  
	    /// number (integer)  
	    number_integer_t number_integer;  
	    /// number (unsigned integer)  
	    number_unsigned_t number_unsigned;  
	    /// number (floating-point)  
	    number_float_t number_float;
	    ......
	};
  public:
	// 借助ObjectType这个类模板模板参数，将object_t完整定义出来
	// json对象的key是StringType，value则是basic_json本身
	// ObjectType默认实参是std::map
	// 后面的Compare和Allocator参数则完全照搬std::map的默认模板参数
	using object_t = ObjectType<StringType,  
	  basic_json,  
	  std::less<StringType>,  
	  AllocatorType<std::pair<const StringType,  
	  basic_json>>>;	
	// 如法炮制出数组类型，默认实参是std::vector，element类型为basic_json本身
	using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
	using string_t = StringType;
	using boolean_t = BooleanType;
	using number_integer_t = NumberIntegerType;
	using number_unsigned_t = NumberUnsignedType;
	using number_float_t = NumberFloatType;
	using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
};```
因为一个`basic_json`对象在同一时刻只能是上述类型的某一种，一整个json字符串应该是自顶向下，由多个类型各异的`basic_json`对象嵌套而成，因此，`json_value`在设计上使用`union`是自然而然的。每种类型的定义通过模板参数来实现，其中`binary_t`较为复杂，它单独做了一层封装，我们暂且按下不表，留待后续讨论。

在`data`中，`m_type`用于表示该`basic_json`对象具体是哪种类型，`m_value`则存储对应的具体值。

我们还观察到`data`有个很特别的构造器：

```cpp
data(const value_t v)  : m_type(v), m_value(v)  {} 
```
在成员初始化列表中，`m_type`的初始化是显而易见的，`m_value`则有着特定的初始化构造逻辑：

```cpp
json_value(value_t t)  
{  
    switch (t)  
    {  
        case value_t::object:  
        {  
            object = create<object_t>();  
            break;        }  
  
        case value_t::array:  
        {  
            array = create<array_t>();  
            break;        }  
  
        case value_t::string:  
        {  
            string = create<string_t>("");  
            break;        }  
  
        case value_t::binary:  
        {  
            binary = create<binary_t>();  
            break;        }  
  
        case value_t::boolean:  
        {  
            boolean = static_cast<boolean_t>(false);  
            break;        }  
  
        case value_t::number_integer:  
        {  
            number_integer = static_cast<number_integer_t>(0);  
            break;        }  
  
        case value_t::number_unsigned:  
        {  
            number_unsigned = static_cast<number_unsigned_t>(0);  
            break;        }  
  
        case value_t::number_float:  
        {  
            number_float = static_cast<number_float_t>(0.0);  
            break;        }  
  
        case value_t::null:  
        {  
            object = nullptr;   
            break;  
        }  
  
        case value_t::discarded:  
        default:  
        {  
            object = nullptr;    
            if (JSON_HEDLEY_UNLIKELY(t == value_t::null))  
            {  
                JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.3", nullptr));
            }  
            break;  
        }  
    }
}

template<typename T, typename... Args>  
static T* create(Args&& ... args)  
{  
    AllocatorType<T> alloc;  
    using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;  
  
    auto deleter = [&](T * obj)  
    {  
        AllocatorTraits::deallocate(alloc, obj, 1);  
    };  
    std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);  
    AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);  
    JSON_ASSERT(obj != nullptr);  
    return obj.release();  
}
```

对于上述`data`构造函数来说，构造的`m_value`就是特定类型的默认零值。对于指针型成员，这里在类内函数模板`create`来创建对象，由于`basic_json`可以支持用户去指定`AllocatorType`，故这里也要沿用模板参数所指定的内存分配器。

当然，`json_value`还应支持各种特定类型作为参数的构造器，诸如：

```cpp
/// constructor for strings  
json_value(const string_t& value) : string(create<string_t>(value)) {}  
  
/// constructor for rvalue strings  
json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}

/// constructor for objects  
json_value(const object_t& value) : object(create<object_t>(value)) {}  
  
/// constructor for rvalue objects  
json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}

......
```

按照惯例，设计出接受常量左值引用和右值引用的两个版本，各个类型俱是如此，不多赘述。

此外，`json_value`的构造器既然负责了指针指向对象的构造，那么自然也要有个对称的释放接口，即`destroy`:

```cpp
void destroy(value_t t)  
{  
	// 卫语句
    if (  
        (t == value_t::object && object == nullptr) ||  
        (t == value_t::array && array == nullptr) ||  
        (t == value_t::string && string == nullptr) ||  
        (t == value_t::binary && binary == nullptr)  
    )  
    {  
        //not initialized (e.g. due to exception in the ctor)  
        return;  
    }  
    // 数组和对象型会有嵌套，我们需要自底向上release
    // 这里用BFS处理，使用stack来存储子节点，LIFO，倒序析构
    if (t == value_t::array || t == value_t::object)  
    {  
        // flatten the current json_value to a heap-allocated stack  
        std::vector<basic_json> stack;  
  
        // move the top-level items to stack  
        if (t == value_t::array)  
        {  
            stack.reserve(array->size());  
            std::move(array->begin(), array->end(), std::back_inserter(stack));  
        }  
        else  
        {  
            stack.reserve(object->size());  
            for (auto&& it : *object)  
            {  
                stack.push_back(std::move(it.second));  
            }  
        }  
		// stack内需要释放的obj全部move给局部变量current_item
		// current_item仅能活过一次循环，每次循环退出前触发basic_json析构
		// 进而触发data的析构，执行m_value.destroy(m_type)
        while (!stack.empty())  
        {  
            // move the last item to local variable to be processed  
            basic_json current_item(std::move(stack.back()));  
            stack.pop_back();  
  
            // if current_item is array/object, move  
            // its children to the stack to be processed later            if (current_item.is_array())  
            {  
                std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));  
  
                current_item.m_data.m_value.array->clear();  
            }  
            else if (current_item.is_object())  
            {  
                for (auto&& it : *current_item.m_data.m_value.object)  
                {  
                    stack.push_back(std::move(it.second));  
                }  
  
                current_item.m_data.m_value.object->clear();  
            }  
  
            // it's now safe that current_item get destructed  
            // since it doesn't have any children        }  
    }  
	// 走到这里，object或array型json的所有子对象就全部释放干净了
	// 现在来分解他自己
    switch (t)  
    {  
        case value_t::object:  
        {  
            AllocatorType<object_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, object);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);  
            break;        }  
  
        case value_t::array:  
        {  
            AllocatorType<array_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, array);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);  
            break;        }  
  
        case value_t::string:  
        {  
            AllocatorType<string_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, string);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);  
            break;        }  
  
        case value_t::binary:  
        {  
            AllocatorType<binary_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);  
            break;        }  
  
        case value_t::null:  
        case value_t::boolean:  
        case value_t::number_integer:  
        case value_t::number_unsigned:  
        case value_t::number_float:  
        case value_t::discarded:  
        default:  
        {  
            break;  
        }  
    }  
}
```

实际上整个`destroy`的设计就是一个BFS，底层的对象先释放，顶层的后释放，防止关联丢失。

### 序列化与反序列化
对于json库来说，序列化与反序列化是最核心的功能：
- 反序列化：将一个json字符串解析成一棵嵌套的`basic_json`对象树。
- 序列化：将嵌套的`basic_json`对象树转储到字符串json字面量。

这里的反序列化是通过静态成员函数模板`basic_json::parse`来实现，而序列化则是通过`basic_json`的`dump`成员函数来生成一个json `string`：

```cpp
// parse explicitly
auto j3 = json::parse(R"({"happy": true, "pi": 3.141})");

// explicit conversion to string
std::string s = j.dump();    // {"happy":true,"pi":3.141}

// serialization with pretty printing
// pass in the amount of spaces to indent
std::cout << j.dump(4) << std::endl;
// {
//     "happy": true,
//     "pi": 3.141
// }
```

dump还支持一个`indent`参数来控制输出json的结构化，提高可读性。

#### `parse`
`parse`的实现实际上有2个重载的成员函数模板，前者是最为泛用的版本，后者则主要兼容STL风格，我们先来拆解一下前者的实现，至于后者，会在STL风格适配一节中统一拆解。

```cpp
template<typename InputType>  
static basic_json parse(InputType&& i,  
                        const parser_callback_t cb = nullptr,  
                        const bool allow_exceptions = true,  
                        const bool ignore_comments = false)  
{  
    basic_json result;  
    parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse(true, result);  
    return result;  
}
```

实际的工作都由内部的`parser`来完成，不急，我们先来看看[接口文档](https://json.nlohmann.me/api/basic_json/parse/)：

`InputType`

A compatible input, for instance:

- an `std::istream` object
- a `FILE` pointer (must not be null)
- a C-style array of characters
- a pointer to a null-terminated string of single byte characters
- a `std::string`
- an object `obj` for which `begin(obj)` and `end(obj)` produces a valid pair of iterators.

`cb` (in)

a parser callback function of type [`parser_callback_t`](https://json.nlohmann.me/api/basic_json/parser_callback_t/) which is used to control the deserialization by filtering unwanted values (optional)

`allow_exceptions` (in)

whether to throw exceptions in case of a parse error (optional, `true` by default)

`ignore_comments` (in)

whether comments should be ignored and treated like whitespace (`true`) or yield a parse error (`false`); (optional, `false` by default)

模板参数`InputType&& i`非常灵活，按照类别拆分，大体可以分成三类：
1. 文件类：同时支持C++标准库的`std::istream`对象和传统C标准库的`FILE`指针
2. 字符串字面量：
	1. 可以是C++标准库的`std::string`，可能也是最为常用的。
	2. 也可以是C风格字符数组，即`char[]`。
	3. 还可以是C风格字符串(以`\0`结尾，一般写成`char* str="{}";`)。
3. 一种特殊的对象：它需要支持`begin(obj)`和`end(obj)`操作，并能够生成一组有效的迭代器。

回调对象`cb`则与控制反序列化时不需要的值的过滤有关，它默认是`nullptr`，即无需过滤。`allow_exceptions`默认为`true`，表示在解析json失败时是否要抛出异常。`ignore_comments`则表示是否要忽略注释，如果忽略的话就将其视为空格，否则就抛出一个解析错误，它默认为`false`。

为了能够支持上述三大类模板参数，`parser`抽象出了一个适配器：`InputAdapterType`作为它的首个入参：

```cpp
template<typename InputAdapterType>  
static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(  
    InputAdapterType adapter,  
    detail::parser_callback_t<basic_json>cb = nullptr,  
    const bool allow_exceptions = true,  
    const bool ignore_comments = false  
)  
{  
    return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),  
            std::move(cb), allow_exceptions, ignore_comments);  
}
```

显然，`detail::input_adapter`必定设计成了重载函数，对于不同的`InputType`它会生成各异的`InputAdapterType`，我们且来看看`input_adapter`对于不同的`InputType`会生成哪些产物：

##### `FILE*`

```cpp
// 对于FILE指针
inline file_input_adapter input_adapter(std::FILE* file)  
{  
	// 构造一个file_input_adapter对象
    return file_input_adapter(file);  
}  

class file_input_adapter  
{  
  public:  
	// 用于parser内对InputAdapterType做type trait
    using char_type = char;  
  
    explicit file_input_adapter(std::FILE* f) noexcept  
        : m_file(f)  
    {  
        assert(m_file != nullptr);  
    }  
  
    // make class move-only  
    file_input_adapter(const file_input_adapter&) = delete;  
    file_input_adapter(file_input_adapter&&) noexcept = default;  
    file_input_adapter& operator=(const file_input_adapter&) = delete;  
    file_input_adapter& operator=(file_input_adapter&&) = delete;  
    ~file_input_adapter() = default;  

	// 提供get_character接口，返回型为int
    std::char_traits<char>::int_type get_character() noexcept  
    {  
        return std::fgetc(m_file);  
    }  
  
  private:  
    /// the file pointer to read from  
    std::FILE* m_file;  
};
```

返回的对象简明扼要，C标准库的文件操作确实优雅。
##### `std::istream`

```cpp
// 对于std::istream
inline input_stream_adapter input_adapter(std::istream& stream)  
{  
	// 构造一个input_stream_adapter对象
    return input_stream_adapter(stream);  
}  
  
inline input_stream_adapter input_adapter(std::istream&& stream)  
{  
    return input_stream_adapter(stream);  
}

class input_stream_adapter  
{  
  public:  
	// 用于parser内对InputAdapterType做type trait
    using char_type = char;  
  
    ~input_stream_adapter()  
    {  
        // clear stream flags; we use underlying streambuf I/O, do not  
        // maintain ifstream flags, except eof        if (is != nullptr)  
        {  
            is->clear(is->rdstate() & std::ios::eofbit);  
        }  
    }  
  
    explicit input_stream_adapter(std::istream& i)  
        : is(&i), sb(i.rdbuf())  
    {}  
  
    // delete because of pointer members  
    input_stream_adapter(const input_stream_adapter&) = delete;  
    input_stream_adapter& operator=(input_stream_adapter&) = delete;  
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;  
  
    input_stream_adapter(input_stream_adapter&& rhs) noexcept  
        : is(rhs.is), sb(rhs.sb)  
    {  
        rhs.is = nullptr;  
        rhs.sb = nullptr;  
    }  
  
    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to  
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not    // end up as the same value, e.g. 0xFFFFFFFF.    std::char_traits<char>::int_type get_character()  
    {  
        auto res = sb->sbumpc();  
        // set eof manually, as we don't use the istream interface.  
        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))  
        {  
            is->clear(is->rdstate() | std::ios::eofbit);  
        }  
        return res;  
    }  
  
  private:  
    /// the associated input stream  
    std::istream* is = nullptr;  
    std::streambuf* sb = nullptr;  
};
```

`std::istream`的设计确实挺逆天的，这里不详细解读了，避免喧宾夺主。

##### `字符数组`与C风格字符串

```cpp
// 受限于模板推导的退化，原生数组需要按如下声明
template<typename T, std::size_t N>  
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) 
{  
	// 构造一个input_adapter对象
    return input_adapter(array, array + N);  
}

// 第二个模板参数利用SFINAE对CharT的类型进行了限制
// CharT需要满足如下条件：指针型；不能是数组；底层类型是integral且size为1
// 实际上基本限定了CharT为char，除非你自己diy一个和char类似的类型
template < typename CharT,  
           typename std::enable_if <  
               std::is_pointer<CharT>::value&&  
               !std::is_array<CharT>::value&&  
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&  
               sizeof(typename std::remove_pointer<CharT>::type) == 1,  
               int >::type = 0 >  
contiguous_bytes_input_adapter input_adapter(CharT b)  
{  
    auto length = std::strlen(reinterpret_cast<const char*>(b));  
    const auto* ptr = reinterpret_cast<const char*>(b);  
    return input_adapter(ptr, ptr + length);  
}
```

二者构造的都是`input_adapter`对象：

```cpp
template<typename IteratorType>  
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)  
{  
    using factory_type = iterator_input_adapter_factory<IteratorType>;  
    return factory_type::create(first, last);  
}
```

