C++ json库在设计上所要解决的核心问题就在于：如何提供优雅直观的接口去像JS,Python那样操作json对象。在此基础上，再将性能发挥到极致。

Json本身是一个字符串，它有着特定的fmt，为了能够灵活操作，库设计者需要去把它parse成一个对象，使用设计好的接口去便捷高效操作它。

C++发展了这么多年，诞生了许多知名的json库，这其中，热度最高的便是：[nlohmann/json](https://github.com/sponsors/nlohmann)

本文旨在对该开源仓库进行深度剖析，源码之前，了无秘密。

## Json类设计
用于表达json对象的`class`是`basic_json`类模板，它的定义有5k行代码，看着相当唬人。但实际上，只要我们掌握阅读一个类的方法，了解它的能力，就会发现拆解源代码的实现工作量并不大。

### Json的类型表达
拆解类模板设计的第一步就是看它的模板头声明与类继承关系。

Json的解析无非就是对几种可枚举的类型进行Key/Value的处理：
- 对象
- 数组
- 字符串
- 布尔
- 有符号整型数
- 无符号整型数
- 浮点数
- 二进制bytes

在C++中，每种类型都很容易联想到对应的基础类型或是标准容器。比如对象适合用`std::map`，数组适合用`std::vector`，字符串适合用`std::string`。其他几个也各有合适的基础类型。但直接就绑定使用这些类型未免过于僵硬，库的设计往往都要考虑灵活的延展性，因此，`basic_json`在设计上，允许通过模板参数来指定每一种类型，这在模板元编程中，术语叫做strategy。

```cpp
template<template<typename U, typename V, typename... Args> class ObjectType =  
         std::map,  
         template<typename U, typename... Args> class ArrayType = std::vector,  
         class StringType = std::string, class BooleanType = bool,  
         class NumberIntegerType = std::int64_t,  
         class NumberUnsignedType = std::uint64_t,  
         class NumberFloatType = double,  
         template<typename U> class AllocatorType = std::allocator,  
         template<typename T, typename SFINAE = void> class JSONSerializer =  
         adl_serializer,  
         class BinaryType = std::vector<std::uint8_t>, 
         class CustomBaseClass = void>  
class basic_json 
	: public ::nlohmann::detail::json_base_class<CustomBaseClass> {
	......
};
```

基础类型的指派是一目了然的，这里重点说下`ObjectType`和`ArrayType`，这两个都是模板模板参数，对于前者来说，由于我们只关心对象的KV类型，所以模板参数的前两个`U`和`V`要固定下来，为了能够支持更灵活的类型，额外再提供一个可变模板参数`Args`，后者亦然。`std::map`和`std::vector`满足二者的模板参数列表，它们分别被指定为默认值。

除了类型相关的模板参数以外，这里还指定了默认的内存分配器类型为`std::allocator`，默认的序列化类型为库实现的`adl_serializer`，默认的二进制类型`BinaryType`为`std::vector<std::uint8_t>`，默认的`CustomBaseClass`为`void`。`CustomBaseClass`见名知意，设计的本意是让`basic_json`可以继承用户自定义的某个基类，可能是想继承到某些能力，或是和其他库设计的某些类混用，适用多态的能力。由于默认情况下模板参数指定的是`void`，而在C++语法规则里是不能去继承`void`类型的，因此这里使用type trait技巧包装了一下：

```cpp
struct json_default_base {};  
  
template<class T>  
using json_base_class = typename std::conditional <  
                        std::is_same<T, void>::value,  
                        json_default_base,  
                        T  
                        >::type;
```

实际上直接写作`class CustomBaseClass = detail::json_default_base`达成的效果完全一样，只是`void`更能表达设计的意图。

### 核心类型定义
类模板在设计时，不论是strategy/policy型模板参数，还是直接引用的外部类型，直接使用都较为臃肿。惯例上，会直接（别名）或间接（Type Trait）定义出核心类内类型，一方面可以简化模板实现代码的编写，另一方面也可以屏蔽外部的变化并约束引用的类型。

而想要了解哪些类内定义最为核心，可以从先寻找`basic_json`内部的成员变量出发。`basic_json`类内实际上只有一个成员变量：

```cpp
class basic_json{
	struct data  
	{  
	    /// the type of the current element  
	    value_t m_type = value_t::null;  
	  
	    /// the value of the current element  
	    json_value m_value = {};  
	  
	    data(const value_t v)  
	        : m_type(v), m_value(v)  
	    {  
	    }  
	  
	    data(size_type cnt, const basic_json& val)  
	        : m_type(value_t::array)  
	    {  
	        m_value.array = create<array_t>(cnt, val);  
	    }  
		// 允许默认构造和移动构造，但禁止拷贝
	    data() noexcept = default;  
	    data(data&&) noexcept = default;  
	    data(const data&) noexcept = delete;  
	    data& operator=(data&&) noexcept = delete;  
	    data& operator=(const data&) noexcept = delete;  
	  
	    ~data() noexcept  
	    {  
	        m_value.destroy(m_type);  
	    }  
	};  

	data m_data = {};
};
```
内部类型`data`包裹了整个`basic_json`最为核心的两个类型设计：`value_t`和`json_value`，前者用于表示该`basic_json`对象具体是哪种类型，后者则存储对应的值。

#### `m_type`
显然，对于`value_t`来说，在设计上应该是枚举，我们来看看`value_t`的定义：

```cpp
class basic_json {
public:  
  using value_t = detail::value_t;
};

enum class value_t : std::uint8_t  
{  
    null,             ///< null value  
    object,           ///< object (unordered set of name/value pairs)  
    array,            ///< array (ordered collection of values)  
    string,           ///< string value  
    boolean,          ///< boolean value  
    number_integer,   ///< number value (signed integer)  
    number_unsigned,  ///< number value (unsigned integer)  
    number_float,     ///< number value (floating-point)  
    binary,           ///< binary array (ordered collection of bytes)  
    discarded         ///< discarded by the parser callback function  
};
```
果然与我们的猜想如出一辙。

`m_value`
再来看看`json_value`:

```cpp
class basic_json {
  private:
	union json_value  
	{  
	    /// object (stored with pointer to save storage)  
	    object_t* object;  
	    /// array (stored with pointer to save storage)  
	    array_t* array;  
	    /// string (stored with pointer to save storage)  
	    string_t* string;  
	    /// binary (stored with pointer to save storage)  
	    binary_t* binary;  
	    /// boolean  
	    boolean_t boolean;  
	    /// number (integer)  
	    number_integer_t number_integer;  
	    /// number (unsigned integer)  
	    number_unsigned_t number_unsigned;  
	    /// number (floating-point)  
	    number_float_t number_float;
	    ......
	};
  public:
	// 借助ObjectType这个类模板模板参数，将object_t完整定义出来
	// json对象的key是StringType，value则是basic_json本身
	// ObjectType默认实参是std::map
	// 后面的Compare和Allocator参数则完全照搬std::map的默认模板参数
	using object_t = ObjectType<StringType,  
	  basic_json,  
	  std::less<StringType>,  
	  AllocatorType<std::pair<const StringType,  
	  basic_json>>>;	
	// 如法炮制出数组类型，默认实参是std::vector，element类型为basic_json本身
	using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;
	using string_t = StringType;
	using boolean_t = BooleanType;
	using number_integer_t = NumberIntegerType;
	using number_unsigned_t = NumberUnsignedType;
	using number_float_t = NumberFloatType;
	using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;
};```
因为一个`basic_json`对象在同一时刻只能是上述类型的某一种，一整个json字符串应该是自顶向下，由多个类型各异的`basic_json`对象嵌套而成，因此，`json_value`在设计上使用`union`是自然而然的。每种类型的定义通过模板参数来实现，其中`binary_t`较为复杂，它单独做了一层封装，我们暂且按下不表，留待后续讨论。

在`data`中，`m_type`用于表示该`basic_json`对象具体是哪种类型，`m_value`则存储对应的具体值。

我们还观察到`data`有个很特别的构造器：

```cpp
data(const value_t v)  : m_type(v), m_value(v)  {} 
```
在成员初始化列表中，`m_type`的初始化是显而易见的，`m_value`则有着特定的初始化构造逻辑：

```cpp
json_value(value_t t)  
{  
    switch (t)  
    {  
        case value_t::object:  
        {  
            object = create<object_t>();  
            break;        }  
  
        case value_t::array:  
        {  
            array = create<array_t>();  
            break;        }  
  
        case value_t::string:  
        {  
            string = create<string_t>("");  
            break;        }  
  
        case value_t::binary:  
        {  
            binary = create<binary_t>();  
            break;        }  
  
        case value_t::boolean:  
        {  
            boolean = static_cast<boolean_t>(false);  
            break;        }  
  
        case value_t::number_integer:  
        {  
            number_integer = static_cast<number_integer_t>(0);  
            break;        }  
  
        case value_t::number_unsigned:  
        {  
            number_unsigned = static_cast<number_unsigned_t>(0);  
            break;        }  
  
        case value_t::number_float:  
        {  
            number_float = static_cast<number_float_t>(0.0);  
            break;        }  
  
        case value_t::null:  
        {  
            object = nullptr;   
            break;  
        }  
  
        case value_t::discarded:  
        default:  
        {  
            object = nullptr;    
            if (JSON_HEDLEY_UNLIKELY(t == value_t::null))  
            {  
                JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.11.3", nullptr));
            }  
            break;  
        }  
    }
}

template<typename T, typename... Args>  
static T* create(Args&& ... args)  
{  
    AllocatorType<T> alloc;  
    using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;  
  
    auto deleter = [&](T * obj)  
    {  
        AllocatorTraits::deallocate(alloc, obj, 1);  
    };  
    std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);  
    AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);  
    JSON_ASSERT(obj != nullptr);  
    return obj.release();  
}
```

对于上述`data`构造函数来说，构造的`m_value`就是特定类型的默认零值。对于指针型成员，这里在类内函数模板`create`来创建对象，由于`basic_json`可以支持用户去指定`AllocatorType`，故这里也要沿用模板参数所指定的内存分配器。

当然，`json_value`还应支持各种特定类型作为参数的构造器，诸如：

```cpp
/// constructor for strings  
json_value(const string_t& value) : string(create<string_t>(value)) {}  
  
/// constructor for rvalue strings  
json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}

/// constructor for objects  
json_value(const object_t& value) : object(create<object_t>(value)) {}  
  
/// constructor for rvalue objects  
json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}

......
```

按照惯例，设计出接受常量左值引用和右值引用的两个版本，各个类型俱是如此，不多赘述。

此外，`json_value`的构造器既然负责了指针指向对象的构造，那么自然也要有个对称的释放接口，即`destroy`:

```cpp
void destroy(value_t t)  
{  
	// 卫语句
    if (  
        (t == value_t::object && object == nullptr) ||  
        (t == value_t::array && array == nullptr) ||  
        (t == value_t::string && string == nullptr) ||  
        (t == value_t::binary && binary == nullptr)  
    )  
    {  
        //not initialized (e.g. due to exception in the ctor)  
        return;  
    }  
    // 数组和对象型会有嵌套，我们需要自底向上release
    // 这里用BFS处理，使用stack来存储子节点，LIFO，倒序析构
    if (t == value_t::array || t == value_t::object)  
    {  
        // flatten the current json_value to a heap-allocated stack  
        std::vector<basic_json> stack;  
  
        // move the top-level items to stack  
        if (t == value_t::array)  
        {  
            stack.reserve(array->size());  
            std::move(array->begin(), array->end(), std::back_inserter(stack));  
        }  
        else  
        {  
            stack.reserve(object->size());  
            for (auto&& it : *object)  
            {  
                stack.push_back(std::move(it.second));  
            }  
        }  
		// stack内需要释放的obj全部move给局部变量current_item
		// current_item仅能活过一次循环，每次循环退出前触发basic_json析构
		// 进而触发data的析构，执行m_value.destroy(m_type)
        while (!stack.empty())  
        {  
            // move the last item to local variable to be processed  
            basic_json current_item(std::move(stack.back()));  
            stack.pop_back();  
  
            // if current_item is array/object, move  
            // its children to the stack to be processed later            if (current_item.is_array())  
            {  
                std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));  
  
                current_item.m_data.m_value.array->clear();  
            }  
            else if (current_item.is_object())  
            {  
                for (auto&& it : *current_item.m_data.m_value.object)  
                {  
                    stack.push_back(std::move(it.second));  
                }  
  
                current_item.m_data.m_value.object->clear();  
            }  
  
            // it's now safe that current_item get destructed  
            // since it doesn't have any children        }  
    }  
	// 走到这里，object或array型json的所有子对象就全部释放干净了
	// 现在来分解他自己
    switch (t)  
    {  
        case value_t::object:  
        {  
            AllocatorType<object_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, object);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);  
            break;        }  
  
        case value_t::array:  
        {  
            AllocatorType<array_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, array);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);  
            break;        }  
  
        case value_t::string:  
        {  
            AllocatorType<string_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, string);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);  
            break;        }  
  
        case value_t::binary:  
        {  
            AllocatorType<binary_t> alloc;  
            std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);  
            std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);  
            break;        }  
  
        case value_t::null:  
        case value_t::boolean:  
        case value_t::number_integer:  
        case value_t::number_unsigned:  
        case value_t::number_float:  
        case value_t::discarded:  
        default:  
        {  
            break;  
        }  
    }  
}
```

实际上整个`destroy`的设计就是一个BFS，底层的对象先释放，顶层的后释放，防止关联丢失。

